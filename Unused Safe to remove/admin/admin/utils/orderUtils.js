/**
 * Order-related utility functions and calculations
 */

/**
 * @deprecated Order IDs are now generated by the backend in format: HB-Jan'25-15-000079
 * This function is kept for backward compatibility only and should not be used for new orders.
 * Backend generates IDs automatically via Order model pre('validate') hook.
 */
export const generateUniqueOrderId = (date = null, existingOrders = []) => {
  console.warn(
    '[DEPRECATED] generateUniqueOrderId: Order IDs are now generated by backend. Use POST /api/orders/manual instead.'
  );
  // Return a temporary placeholder - backend will generate proper ID
  const orderDate = date ? new Date(date) : new Date();
  const monthNames = [
    'Jan',
    'Feb',
    'Mar',
    'Apr',
    'May',
    'Jun',
    'Jul',
    'Aug',
    'Sep',
    'Oct',
    'Nov',
    'Dec',
  ];
  const month = monthNames[orderDate.getMonth()];
  const year = String(orderDate.getFullYear()).slice(-2);
  const day = String(orderDate.getDate()).padStart(2, '0');
  return `TEMP-${month}'${year}-${day}-XXXXXX`; // Temporary - backend will replace
};

/**
 * Format currency in Indian format (rupees only, no paisa)
 */
export const formatCurrency = (amount) => {
  try {
    const num = parseFloat(amount) || 0;
    return Math.round(num).toLocaleString('en-IN', {
      minimumFractionDigits: 0,
      maximumFractionDigits: 0,
    });
  } catch (error) {
    console.error('Error formatting currency:', error);
    return '0';
  }
};

/**
 * Format number in Indian format without decimals (for chart labels)
 * Shows full amount like 250, 2,450, 35,682 instead of abbreviated like 2k, 1k
 */
export const formatNumberIndian = (amount) => {
  try {
    const num = parseFloat(amount) || 0;
    return Math.round(num).toLocaleString('en-IN');
  } catch (error) {
    console.error('Error formatting number:', error);
    return '0';
  }
};

/**
 * Get total revenue (all orders)
 * Handles both total and totalAmount fields, with fallback to quantity * unitPrice
 */
export const getTotalRevenue = (ordersList = []) => {
  try {
    return ordersList.reduce((sum, order) => {
      if (!order) return sum;
      // Try total first, then totalAmount
      let amount = parseFloat(order.total || order.totalAmount || 0);
      // If amount is missing or invalid, calculate from quantity * unitPrice
      if (isNaN(amount) || amount === 0) {
        const qty = parseFloat(order.quantity || 1);
        const price = parseFloat(order.unitPrice || 0);
        amount = qty * price;
      }
      return sum + (isNaN(amount) ? 0 : amount);
    }, 0);
  } catch (error) {
    console.error('Error calculating total revenue:', error);
    return 0;
  }
};

/**
 * Get delivered revenue (only delivered orders)
 */
export const getDeliveredRevenue = (ordersList = []) => {
  try {
    return ordersList
      .filter((order) => order && order.status === 'delivered')
      .reduce((sum, order) => {
        const amount = parseFloat(order.total || order.totalAmount || 0);
        return sum + (isNaN(amount) ? 0 : amount);
      }, 0);
  } catch (error) {
    console.error('Error calculating delivered revenue:', error);
    return 0;
  }
};

/**
 * Get order date only (no time component)
 */
export const getOrderDateOnly = (order) => {
  try {
    if (!order) return null;
    const dateValue = order.createdAt || order.date;
    if (!dateValue) return null;
    const orderDate = new Date(dateValue);
    if (isNaN(orderDate.getTime())) {
      return null;
    }
    const year = orderDate.getFullYear();
    const month = String(orderDate.getMonth() + 1).padStart(2, '0');
    const day = String(orderDate.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  } catch (error) {
    return null;
  }
};

/**
 * Get order year
 */
export const getOrderYear = (order) => {
  try {
    if (!order) return null;
    if (order.year) {
      return String(order.year);
    }
    const dateValue = order.createdAt || order.date;
    if (!dateValue) return null;
    const orderDate = new Date(dateValue);
    if (isNaN(orderDate.getTime())) {
      return null;
    }
    return String(orderDate.getFullYear());
  } catch (error) {
    return null;
  }
};

/**
 * Calculate total amount from quantity and unit price
 * This is the ONLY way total_amount should be calculated
 */
export const calculateTotalAmount = (quantity, unitPrice) => {
  try {
    const qty = parseInt(quantity) || 0;
    const price = parseFloat(unitPrice) || 0;
    return qty * price;
  } catch (error) {
    console.error('Error calculating total amount:', error);
    return 0;
  }
};

/**
 * Extract billing month (1-12) from order date
 */
export const extractBillingMonth = (orderDate) => {
  try {
    if (!orderDate) return null;
    const date = new Date(orderDate);
    if (isNaN(date.getTime())) return null;
    return date.getMonth() + 1; // 1-12
  } catch (error) {
    console.error('Error extracting billing month:', error);
    return null;
  }
};

/**
 * Extract billing year from order date
 */
export const extractBillingYear = (orderDate) => {
  try {
    if (!orderDate) return null;
    const date = new Date(orderDate);
    if (isNaN(date.getTime())) return null;
    return date.getFullYear();
  } catch (error) {
    console.error('Error extracting billing year:', error);
    return null;
  }
};

/**
 * Format billing month for display only (e.g., "February'24")
 * This is NEVER stored, only calculated for display
 */
export const formatBillingMonth = (month, year) => {
  try {
    if (!month || !year) return '';
    const monthNames = [
      'January',
      'February',
      'March',
      'April',
      'May',
      'June',
      'July',
      'August',
      'September',
      'October',
      'November',
      'December',
    ];
    const monthIndex = parseInt(month) - 1;
    if (monthIndex < 0 || monthIndex > 11) return '';
    const yearStr = String(year).slice(-2);
    return `${monthNames[monthIndex]}'${yearStr}`;
  } catch (error) {
    console.error('Error formatting billing month:', error);
    return '';
  }
};

/**
 * Format reference month for display only (e.g., "2(Feb'24)")
 * This is NEVER stored, only calculated for display
 */
export const formatReferenceMonth = (month, year) => {
  try {
    if (!month || !year) return '';
    const monthNames = [
      'Jan',
      'Feb',
      'Mar',
      'Apr',
      'May',
      'Jun',
      'Jul',
      'Aug',
      'Sep',
      'Oct',
      'Nov',
      'Dec',
    ];
    const monthIndex = parseInt(month) - 1;
    if (monthIndex < 0 || monthIndex > 11) return '';
    const yearStr = String(year).slice(-2);
    return `${String(month).padStart(2, '0')} - ${monthNames[monthIndex]}'${yearStr}`;
  } catch (error) {
    console.error('Error formatting reference month:', error);
    return '';
  }
};

/**
 * Normalize order date to YYYY-MM-DD format for comparison
 */
export const normalizeOrderDate = (dateValue) => {
  try {
    if (!dateValue) return null;
    const date = new Date(dateValue);
    if (isNaN(date.getTime())) return null;
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  } catch (error) {
    console.error('Error normalizing order date:', error);
    return null;
  }
};

/**
 * Create composite key from date and address for duplicate detection
 */
export const createOrderKey = (orderDate, deliveryAddress) => {
  try {
    const normalizedDate = normalizeOrderDate(orderDate);
    const normalizedAddress = String(deliveryAddress || '')
      .trim()
      .toLowerCase();
    if (!normalizedDate || !normalizedAddress) return null;
    return `${normalizedDate}|${normalizedAddress}`;
  } catch (error) {
    console.error('Error creating order key:', error);
    return null;
  }
};

/**
 * Find existing order by date and address (for update/insert logic)
 */
export const findOrderByKey = (orders, orderDate, deliveryAddress) => {
  try {
    const key = createOrderKey(orderDate, deliveryAddress);
    if (!key) return null;
    return (
      orders.find((order) => {
        const orderKey = createOrderKey(
          order.date || order.createdAt,
          order.deliveryAddress || order.customerAddress
        );
        return orderKey === key;
      }) || null
    );
  } catch (error) {
    console.error('Error finding order by key:', error);
    return null;
  }
};

/**
 * Get last unit price used for a specific address (for auto-fill)
 */
export const getLastUnitPriceForAddress = (orders, deliveryAddress) => {
  try {
    if (!deliveryAddress || !Array.isArray(orders)) return null;
    const normalizedAddress = String(deliveryAddress).trim().toLowerCase();

    // Find most recent order for this address
    const addressOrders = orders
      .filter((order) => {
        const orderAddress = String(order.deliveryAddress || order.customerAddress || '')
          .trim()
          .toLowerCase();
        return orderAddress === normalizedAddress && order.unitPrice;
      })
      .sort((a, b) => {
        const dateA = new Date(a.createdAt || a.date || 0);
        const dateB = new Date(b.createdAt || b.date || 0);
        return dateB - dateA;
      });

    return addressOrders.length > 0 ? parseFloat(addressOrders[0].unitPrice) : null;
  } catch (error) {
    console.error('Error getting last unit price:', error);
    return null;
  }
};

/**
 * Get last complete order data for a specific address (for auto-fill)
 * Returns the most recent order matching the address, sorted by date descending
 * @param {Array} orders - Array of all orders
 * @param {string} deliveryAddress - Address to search for
 * @returns {Object|null} Last order object or null if not found
 */
export const getLastOrderForAddress = (orders, deliveryAddress) => {
  try {
    if (!deliveryAddress || !Array.isArray(orders)) return null;
    const normalizedAddress = String(deliveryAddress).trim().toLowerCase();

    // Find all orders for this address
    const addressOrders = orders
      .filter((order) => {
        const orderAddress = String(order.deliveryAddress || order.customerAddress || order.address || '')
          .trim()
          .toLowerCase();
        return orderAddress === normalizedAddress;
      })
      .sort((a, b) => {
        // Sort by date descending (most recent first)
        // Use date field first, then order_date, then createdAt
        const dateA = new Date(a.date || a.order_date || a.createdAt || 0);
        const dateB = new Date(b.date || b.order_date || b.createdAt || 0);
        if (dateB.getTime() !== dateA.getTime()) {
          return dateB.getTime() - dateA.getTime();
        }
        // If dates are same, sort by orderId descending to get the very last one
        const idA = (a.orderId || '').toString();
        const idB = (b.orderId || '').toString();
        return idB.localeCompare(idA);
      });

    return addressOrders.length > 0 ? addressOrders[0] : null;
  } catch (error) {
    console.error('Error getting last order for address:', error);
    return null;
  }
};

/**
 * Get unique addresses for autocomplete
 */
export const getUniqueAddresses = (orders) => {
  try {
    if (!Array.isArray(orders)) return [];
    const addressSet = new Set();
    orders.forEach((order) => {
      const address = order.deliveryAddress || order.customerAddress;
      if (address && String(address).trim()) {
        addressSet.add(String(address).trim());
      }
    });
    return Array.from(addressSet).sort();
  } catch (error) {
    console.error('Error getting unique addresses:', error);
    return [];
  }
};

/**
 * Check if order status is considered "Paid"
 * Standardizes status checking across the application
 * @param {string} status - Order status
 * @returns {boolean} True if status is paid/delivered
 */
export const isPaidStatus = (status) => {
  if (!status) return false;
  const s = String(status).toLowerCase().trim();
  return s === 'paid' || s === 'delivered';
};

/**
 * Check if order status is considered "Pending" or "Unpaid"
 * Standardizes status checking across the application
 * @param {string} status - Order status
 * @returns {boolean} True if status is pending/unpaid
 */
export const isPendingStatus = (status) => {
  if (!status) return true; // Treat missing status as pending
  const s = String(status).toLowerCase().trim();
  return s === 'pending' || s === 'unpaid';
};

/**
 * Normalize order status to standard values
 * @param {string} status - Order status
 * @returns {string} Normalized status: 'Paid', 'Pending', or 'Unpaid'
 */
export const normalizeStatus = (status) => {
  if (!status) return 'Pending';
  const s = String(status).toLowerCase().trim();
  if (s === 'paid' || s === 'delivered') return 'Paid';
  if (s === 'pending' || s === 'unpaid') return 'Pending';
  return 'Pending'; // Default to Pending for unknown statuses
};

/**
 * @deprecated Order IDs are now generated by the backend automatically.
 * This function is kept for backward compatibility only.
 * Backend generates IDs in format: HB-Jan'25-15-000079 via Order model pre('validate') hook.
 * @param {Array} orders - Array of orders to process
 * @returns {Array} Array of orders (IDs should come from backend)
 */
export const ensureAllOrdersHaveUniqueIds = (orders) => {
  console.warn(
    '[DEPRECATED] ensureAllOrdersHaveUniqueIds: Order IDs are now generated by backend. This function is kept for backward compatibility only.'
  );
  // Return orders as-is - backend handles ID generation
  return orders;
};
